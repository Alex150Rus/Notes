<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>transformationoftypes</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <style>
    p,
    h4,
    h3 {
      padding: 0 40px;
    }

    p {
      text-align: justify;
    }

    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgb(90, 122, 134);
    }

    .container {
      width: 1140px;
      background: white;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="container">
      <h4>Преобразование типов</h4>
      <p>
        JS может гибко преобразовывать один тип в другой. Везде, где интерпретатор JS ожидает получить логическое
        значение,
        можно указать значение любого типа и JS автоматически выполнит необходимое преобразование. Одни значения
        (истинные)
        преобразуются в true, а другие (ложные) в false. То же относится и к другим типам: Если интерпретатор ожидает
        получить строку, он автоматически преобразует люьое другое значение в строку. Если интерпретатор ожидает
        получить
        число, он попробует преобразовать имеющееся значение в число (в случае невозможности такого преобразования,
        будет
        получено значение NaN):<br>
        10 + " objects" // "10 objects". Число 10 преобразовалось в строку<br>
        "7" * "8" // 28 - обе строки преобразуются в числа<br>
        var n = 1 - "x"; // NaN - строка "x" не может быть преобразованна в число<br>
        n + " objects" // "NaN objects" - NaN преобразуется в строку "NaN"<br>
        Значение true преобразуется в число 1, а false и пустая строка "" в 0. Преобразование простых типов в объекты
        также выполняется достаточно просто: значения простых типов преобразуются в соответствующие объекты-обёртки,
        как если бы вызывался конструктор String(), Number() или Boolean(). Исключения составляют null и undefined:
        любая попытка использовать их в контексте, где требуется объект, вмето преобразования бужет приводить к
        TypeError.
      </p>
      <h4>Преобразования и равенство</h4>
      <p>
        Благодаря гибкости преобразования типов в JS оператор равенства == также гибко определяет равенство значений.
        Все следующие равнества возвращают true:<br>
        null == undefined // Эти два значения считаются равными.<br>
        "0" == 0 // Перед сравнением строка преобразуется в число<br>
        0 == false // Перед сравнением логическое значение преобразуется в число.<br>
        "0" == false // Перед сравнением оба опреанда преобразуются в числа<br>
        Оператор равенства == выполняет преобразования, а оператор идентичности === не выполняет. Но возможность
        преобразования одного значения в другое не означает равенства этих двух значений. Если, например, в логическом
        контексте используется значение undefined, оно будет преобразованно в значение false. Но это не означает, что
        undefined == false. Операторы и инструкции JS ожидают получить значение определённых типов и выполняют
        преобразования в эти типы. Инструкция if преобразует значение undefined в false, но оператор == никогда не
        пытается преобразовать свои опреанды в логические значения.
      </p>
      <h4>Явные преобразования</h4>
      <p>
        Несмотря на то, что многие преобразования типов JS выполняет автоматически, иногда может оказаться необходимым
        выполнить преобразование явно или окажется предпочтительным явное преобразование, чтобы обеспечить ясность
        программного кода.
        Простейший способ выполнить преобразование типа явно заключается в использовании функций Boolean(), Number(),
        String() и Object(). Мы уже видели как эти функции используются в роли конструкторов объектов - обёрток. При
        вызове без опретора new они действуют как функции преобразования:<br>
        Number("3") // 3<br>
        String(false) // "false" или можно использовать false.toString()<br>
        Boolean([]) // true<br>
        Object(3) // new Number(3)<br>
        Все значения кроме null И undefined имеют метод toString(), результатом которого я вляется то же значение,
        которое возвращается функцией String(). При попытке преобразовать значение null или undefined в объект
        возбуждается ошибка TypeError. Функция Object() в этом случае не возбуждает исключение, вместо этого она
        возвращает новый пустой объект.<br>
        Определённые опреторы в JS неявно выполняют преобразования и иногда могут использоваться для преобразования
        типов. Если один из опренадов опреатора + является строкой, то другой оператор также преобразуется в строку.
        Унарный опреатор + преобразует свой операнд в число. А унарный оператор ! преобразует опреанд в логическое
        значение и инвертирует его:<br>
        x + "" // тоже, что и String(x)<br>
        +x // тоже, что и Number(x). Можно встретить x-0<br>
        !!x // тоже что и Boolean(x). Обращаем внимание на два знака !<br>
        Форматирование и парсинг чисел являются наиболее типичными задачами, поэтому в JS имеются специализированные
        функции и методы, обеспечивающие более полный контроль над преобразованиями чиселв строки и наоборот.<br>
        Метод toString() класса Number принимает необязательный аргумент, определяющий основание системы счисления
        для преобразования. Если аргумент не определён, то преобразование выполняется в десятичной системе. Мы
        можеи производить преобразования в любой системе счисления (с основанием от 2 до 36):<br>
        var n = 17;<br>
        binary_string = n.toString(2); // вернёт '10001'<br>
        octal_string = "0" + n.toString(8); /вернёт "021"<br>
        hex_string = "0x" + n.toString(16); /вернёт "0x11"<br>
        При выполнении финансовых или нацчных расчётов может потребоваться обеспечить преобразование чисел в строки
        с точностью до определённого количества значящих разрядов или получать представление чисел в экспоненциальной
        форме. Для подобный преобразование чисел в строки класс Number определяет 3 метода. Метод toFixed() преобразует
        число в строку, позволяя указывать количество десятичных цифр после запятой. Он никогда не возвращает строки
        с экспоненциальным представлением чисел. Метод toExponential() преобразует число в встроку в экспоненциальном
        представлении, когда перед запятой находится единственный знак, а после запятой следует указанное количество
        цифр(т.е. количество значящих цифр в строке получается на одну больше, чем было указано при вызове метода).
        Метод toPrecision() преобразует число в строку, учитывая количество заданных значащих разрядов. Если заданное
        количество значащих разрядов оказывается недостаточным для отображения всей целой части числа, преобразование
        выполняется в экспоненциальной форме. Все три метода округляют последние цифры или добавляют нули, если это
        необходимо.<br>
        var n = 123456.789<br>
        n.toFixed(0); // "123457"<br>
        n.toFixed(2); // "123456.79"<br>
        n.toFixed(5); // "123456.78900"<br>
        n.toExponential(1); // "1.2e+5"<br>
        n.toExponential(3); // "1.235e+5"<br>
        n.toPrecision(4); // "1.235e+5"<br>
        n.toPrecision(7); // "123456.8"<br>
        n.toPrecision(10); // "123456.7890"<br>
        Если передать строку функции преобразования Number(), она попытается разобрать эту строку как литерал целого
        или вещественного числа. Эта функция работает с десятичными целыми числами и не допускает наличие в строке
        завершающих символов, не являющихся частью литерала числа(т.е. Number("56x") вернёт NaN). Функция parseInt()
        и parseFloat() (это глобальные функции, а не методы какого-либо класса) являются более гибкими. Функция
        parseInt анализирует только целые числа, тогда как parseFloat() позволяет анализировать строки, представляющие
        и целые и вещественные числа. Если строка на начинается с последовательности "0x" или "0X", функция parseInt()
        интерпретирукет её как представление шестнадцатиричного числа. Согласно стандарту ECMAScript 3 функция
        parseInt() может выполнять преобразование строки, начинающейся с символа "0" (но не "0x" или "0X"), в
        восьмеричное или десятичное число. Поскольку поведение функции чётко не определено, следует избегать
        использование функции parseInt() для интерпретации строк, начинающихся с "0", или явно указывать основание
        системы счисления. В ECMAScript5 функция parseInt() будет интерпретировать строки как восьмеричные числа,
        только если ей во втором аргументе явно указать основание 8 системы счисления.<br>
        Обе функции, parseInt() и parseFloat(), пропускают начальные пробельные символы и и пытаются разобрать
        максимально возможное количество символов числа и игнорируют всё, что следует за ними. Если первый
        непробельный символ строки не является частью допустимого числового литерала, эти функции возвращают
        значение NaN:<br>
        parseInt("3 blind mice") // 3<br>
        parseFloat(" 3.14 meters") //3.14<br>
        parseInt("-12.34") //-12<br>
        parseInt("0xFF") // 255<br>
        parseInt("0xff") //255<br>
        parseInt("-0XFF") //-255<br>
        parseFloat(".1") //0.1<br>
        parseInt("0.1") //0<br>
        parseInt(".1") //NaN: целые числа не могут начинаться с "."<br>
        parseFloat("$72.47"); // NaN: числа не могут начинаться с "$"<br>
        Функция parseInt() принимает второй необязательный аргумент, определяющий основание системы счисления для
        разбираемого числа. Допустимые значения от 2 до 36.<br>
        parseInt("11", 2); //3 (1x2+1)<br>
        parseInt("ff", 16); //255 (15*16+15)<br>
        parseInt("zz", 36); // 1295 (36*36+35)<br>
        parseInt("077", 8); // 63 (7*8 + 7)<br>
        parseInt("077", 10); // 77 (7*10 + 7)<br>
      </p>
      <h4>Преобразование объектов в простые значения</h4>
      <p>
        Преобразование объектов в логические значения выполняется очень просто: все объекты (включая массивы
        и функции) преобразуются в true. Это справедливо и для объектов обёрток: результатом вызова
        new Boolean(false) являнтся объект, а не простое значение, поэтому он также преобразуется в true.<br>
        Преобразование объекта встроку и преобразование объекта в число выполняется вызовом соответствующего
        метода объекта. Всё осложняется тем, что объекты в JS имеют два разных метода для выполнения
        преобразований, а также наличием нескольких спеуиальных случаев. Правила преобразования объектов в
        строки и числа, описываемые здесь, применяются только к объектам самого языка JS. Объекты среды
        выполнения (например, определяемые веб браузерами) могут предусматривать собственные алгоритмы
        преобразования в числа и строки.<br>
        Все объекты наследуют два метода преобразования. Первый - toString() - возвращает строковое
        представление объекта. По умолчанию метод toString() не возвращает ничего особенно интересного
        (хотя эта информация иногда может оказаться полезной):<br>
        ({x:1, y:2}).toString() // => "[object Object]"<br>
        Многие классы определяют более специализированные версии метода toString(). Например, метод toString()
        класса Array преобразует все элементы массива в строки и объединяет результат в одну строку,
        вставляя запятые между ними. Метод toString() класса Function возвращает строковое представление
        функции, зависящее от реализации. На практике обычно реализации преобразуют пользовательские функции
        в строки с исходным программным кодом на языке JS.<br>
        Класс Date определяет метод toString(), возвращающий строку с датой и временем в удобном формате
        (который может быть разобран средствами JS).<br>
        Класс RegExp определяет метод toString(), преобразующий объект RegExp в строку, которая как выглядит
        как литерал регулярного выражения:<br>
        [1, 2, 3].toString() // "1,2,3"<br>
        (function(x) { f(x;) }).toString() //"function(x) {\nf(x);\n}"<br>
        /\d+/g.toString() // "/\\d+/g"<br>
        new Date(2010,0,1).toString() // "Fri Jan 01 2010 00:00:00 GMT+0300"<br>
        Другая функция преобразования объектов называется valueOf(). Задача этого метода определена не так
        чётко. Предполагается, что он должен преобразовать объект в представляющее его простое значение,
        если такое значение существует. Объекты по своей природе являются составными значениями, и
        большинство объектов не может быть представлено в виде идинственного простого значения, поэтому
        по умолчанию метод valueOf() возвращает не простое значение, а сам объект. Классы-обёртки определяют
        методы valueOf(), возвращающие обёрнутые простые значения. Массивы, функции и регулярные выражения
        наследуют метод по умолчанию. Вызов метода valueOf() экземпляров этих типов возвращает сам объект.
        Класс Date определяет метод valueOf(), возвращающий дату во внутреннем представлении: колличество
        миллисекунд, прошедших с 1 января 1970 года:<br>
        var d = new Date(2010, 0, 1);<br>
        d.valueOf() // 1262293200000<br>
        Пребразование объектов в строку интерпретатор JS выполняет в два этапа:<br>
        1) если объект имеет метод toString(), интерпретатор вызывает его. Если он возвращает простое
        значение, интерпретатор преобразует значение в строку (если оно не является строкой) и
        возвращает результат преобразования.<br>
        2) если объект не имеет метода to String() или этот метод не возвращает простое значение, то
        интерпретатор проверяет наличие метода valueOf(). Если этот метод определён, интерпретатор вызывает
        его. Если он возвращает простое значение, интерпретатор преобразует это значение в строку (если
        оно не является строкой) и возвращает результат преобразования.<br>
        3) в противном случае интерпретатор делает вывод, что ни toString(), ни valueOf() не
        позволяют получить простое значение и возбуждают исключение TypeError<br><br>
        
        При преобразовании объекта в число интерпретатор выполняет те же действия, но первым пытается
        применить метод valueOf():<br>
        1) если объект имеет метод valueOf(), возвращающий простое значение, интерпретатор преобразует
        (при необходимости) это значение в число и возвращает результат.<br>
        2) иначе, если объект имеет метод toString(), возвращающий простое значение, интерпретатор
        выполняет преобразование и возвращает полученное значение.<br>
        3) в противном случае возбуждается исключение TypeError.<br>
        Описанный алгоритм преобразования объекта в число объясняет почему пустой массив преобразуется
        в число 0, а массив с единственным элементом может быть преобразован в обычное число. Массивы
        наследуют по умолчанию метод valueOf(), который возвращает сам объект, а не простое значение,
        поэтому при преобразовании массива в число интерпретатор опирается на метод toString(). Пустые
        массивы преобразуются в пустую строку, а пустая строка преобразуется в число 0. Массив с
        единственным элементом преобразуется в ту же строку, что и единственный элемент массива. Если
        массив содержит единственное число, это числопреобразуется в строку, а затем опять в число.<br>
        Оператор + в JS выполнет сложение и конкатенацию строк. Если какой-либо из его операндов является
        объектом, JS преобразует объект, используя специальное преобразование объекта в простое значение
        вместо преобразования объекта в число. Тоже относится и к опреатору равенства ==. Если 
        выполняетмя сравнение объекта с простым значением, оператор выполнит преобразование объекта с
        использованием правил преобразования в простое значение.<br>
        Преобразование объектов в простые значения, используемое опреаторами + и ==, предусматривает
        особый подход для объектов Date. Класс Date является единственным типом данных в базовом JS,
        который определяет осмысленные преобразования и в строку и в число. Преобразование любого
        объекта, не являющегося датой, в простое значение основано на преобразовании в число (когда
        превым применяется метод valueOf()), тогда как для объектов типа Date используется
        преобразование в строку (первым применяется метод toString()). Оданко преобразование выполняется
        не совсем так как было описано выше: простое значение, возвращаемое методом valueOf() или
        toString(), используется непоследственно, без дополнительного преобразования в число или строку<br>
        Оператор < и другие операторы отношений выполняют преобразование объектов в простые значения
        подобно оператору ==, но не выделяя объекты Date: для любого объекта сначала предпринимается попытка
        применить метод valueOf(), а затем метод toString(). Любое простое значение, полученное таким
        способом, используется непосредственно, без дальнейшего преобразования в число или строку.<br>
        +, ==, != и операторы отношений являются единственными, выполняющими специальное преобразование
        строки в простое значение. Другие операторы выполняют более явные преобразования в заданный тип
        и не предусматривают специальной обработки объектов Date. Оператор -, например, преобразует свои
        операнды в числа. Следующий фрагментдемонстрирует поведение операторов +, -, == и > при работе
        с объектами Date:<br>
        var now = new Date();<br>
        typeof (now+1) // "строка": + преобразует дату в строку<br>
        type of(now-1) // "число": - выполнит преобразование объекта в число<br>
        now == now.toString() // true: неявное и явное преобразование в строку<br>
        now > (now - 1) // true: преобразует объект Date в число.<br>
      </p>
    </div>
  </div>
</body>

</html>