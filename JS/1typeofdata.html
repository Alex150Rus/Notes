<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>typeofdata</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <style>
    p,
    h4,
    h3 {
      padding: 0 40px;
    }

    p {
      text-align: justify;
    }

    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgb(90, 122, 134);
    }

    .container {
      width: 1140px;
      background: white;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="container">
      <h3>Типы данных, значения и переменные</h3>
      <h4>Типы данных.</h4>
      <p>
        Типы данных в JS: простые типы и объекты. Простые типы: числа, строки, логические или булевы значения.
        Специальные значения - null и undefined.
        null и undefined являются элементарными значениями. Объекты - объекты, массивы, функции.<br>
        Функции в JS являются самыми настоящими значениями и программы JS могут манипулировать ими как обычными
        объектами.<br>
        Функции, которые пишутся для инициализации вновь создаваемых объектов (с опреатором new), называются
        конструкторами. Каждый конструктор определяет класс объектов - множество объектов, инициализируемых
        этим конструктором. Классы - подтипы объектного типа: Array, Function, Date, RegExp, Error.<br>
        Типы данных можно разделить на простые и объектные. Кроме этого, типы можно характеризовать как
        изменяемые и неизменяемые. Значения изменяемого типа можно изменить. Объекты и массивы относятся к
        изменяемым типам: можно изменять значения свойств объектов и элементов массива. Числа, логические
        значения, null, undefined и даже строки - являются неизменямыми. Строки предусматривают возможность
        обращения к символам по числовым индексам, но в JS отсутствует возможность изменить существующую
        текстовую строку.
      </p>
      <h4>Сборщик мусора</h4>
      <p>
        Итерпретатор JS автоматически выполняет сборку мусора в памяти. Это означает, что программа может
        создавать объекты по мере необходимости, но программисту не нужно беспокоиться об уничтожении этих
        объектов и об освобождении занимаемой ими памяти. Когда интерпретатор обнаруживает, что данный объект
        никогда больше не сможет использоваться, он автоматически освободит занимаемую им память.
      </p>
      <h4>ООП</h4>
      <p>
        JS - объектно-ориентированный ЯП. Типы сами могут определять методы для обработки значений. Например,
        чтобы отсортировать элементы массива a, не обязательно передавать массив а функции sort(). Вместо этого
        можно просто вызвать метод sort() массива a: a.sort().<br>
        С технической точки зрения в языке JS только объекты могут иметь методы. Однако числа, строки и
        логические значения ведут себя так, как если бы они обладали методами. Значения null и undefined
        являются единственными, которые не имеют методов.
      </p>
      <h4>Значения null и undefined</h4>
      <p>
        Ключевое слово null в JS имеет специальное значение и используется для обозначения отсутствия значения.
        Оператор typeof для значения null возвращает строку 'object', что говорит о том, что значение null
        является специальным пустым объектом. Однако на практике значение null обычно считается единственными
        членом собственного типа и может использоваться как признак отсутствия значения, такого как число,
        строка или объект.<br>
        Также в JS имеется ещё одно значение, свидетельствующее об отсутствии значения. Оно возвращается при
        обращении к переменной, которой никогда не присваивалось значение, а также к несуществующему свойству
        объекта или элементу массива. Кроме того, значение undefined возвращается функциями, не имеющими
        возвращаемого значения, и присваивается параметрам функций для аргументов, которые не были переданы
        при вызове. Идентификатор undefined является именем предопределённой глобальной переменной (а не
        ключевым словом как null), которая инициализированна значение undefined. Оператор typeof для значения
        undefined возвращает строку 'undefined', показывающую, что данное значение является единственным
        членом специального типа.<br>
        Не смотря на эти отличия, оба значения, null и undefined, являются признаком отсутствия значения и
        часто являются взаимозаменяемыми. Опретор равенства == считает их равными. Чтобы отличать их в
        программе можно использовать оператор идентичности ===. Оба они являются ложными значениями и в
        логическом смысле интерпретируются как false. Они не имеют свойств или методов. Попытка использовать
        . или [], вызывает ошибку TypeError.<br>
        Значение undefined можно рассматривать как признак неожиданного или ошибочного отсутствия какого-либо
        значения, a null - как признак обычного или вполне ожидаемого отсутствия значения. Если в
        программе потребуется присвоить одно из этих значений переменной или свойству или передать одно из
        этих значений функции, практически всегда предпочтительнее использовать null.
      </p>
      <h4>Глобальный объект</h4>
      <p>
        Глобальный объект - это обычный объект JS, который играет очень важную роль: свойства этого объекта
        являются глобальными идентификаторами, доступными из любого места в программах JS. Когда
        выполняется запуск интерпретатора JS (или когда веб браузер загружает новую страницу), создаётся
        новый глобальный объект, в котором инициализируется начальный набор свойств, определяющих:<br>
        - глобальные свойства, такие как undefined, Infinity и NaN;<br>
        - глобальные функции, такие как isNaN(), parseInt(), eval();<br>
        - функции конструкторы, такие как Date(), RegExp(), String(), Object(), Array();<br>
        - глобальные объекты, такие как Math и JSON.<br>
        В клиентском JS имеется объект Window, определяющий другие глобальные свойства. В программном
        коде верхнего уровня, т.е. в JS коде, который не является частью функции, сослаться на глобальный
        объект можно посредством ключевого слова this.<br>
        В клиентском JS роль глобального объекта для всего JS кода, содержащегося в соответствующем ему окне
        браузера, играет объект Window. Этот глобальный объект имеет свойство window, ссылающееся на сам
        объект, которое можно использовать вместо ключевого свойства this для ссылки на глобальный объект.
        Объект Window определяет базовые глобальные свойства, а также дополнительные глобальные свойства,
        характерные для веб-боаузеров и клиентского JS.<br>
        При создании в глобальном объекте определяются все предопределённые глобальные значения JS.
        Однако этот специальный объект может также хранить глобальные переменные программы. Если программа
        объявляет глобальную переменную, она становится свойством глобального объекта.
      </p>
      <h4>Объекты-обёртки</h4>
      <p>
        Строки обладают свойствами и методами, но не являются объектами. Всякий раз, когда в программе
        предпринимается попытка обратиться к свойству строки, интерпретатор JS преобразует строковое
        значение в объект, как если бы был выполнен вызов new String(s). Этот объект наследует строковые
        методы и используется интерпретатором для доступа к свойствам. После обращения к свойству
        вновь созданный объект уничтожается.<br>
        Наличие методов у числовых и логических значений объясняется теми же причинами: при обращении к
        какому-либо методу создаётся временный объект вызовом конструктора Number() или Boolean(), после
        чего производится вызов метода этого объекта. Значения null и undefined не имеют объектов-обёрток:
        любые попытки обратиться к свойствам этих значений будут вызывать ошибку TypeError.<br>
        Давайте подумаем что происходит при выполнении этого кода:<br>
        var s = "test"; // начальное строковое значение.<br>
        s.len = 4; // Установить его свойство.<br>
        var t = s.len; //запросить значение свойства.<br>
        В начале этого фрагмента перемнная t имеет значение undefined. Вторая строка создаёт временный
        объект String, устанавливает его свойство len равным 4 и затем уничтожает этот объект. Третья
        строка создаёт из оригинальной (неизменённой) строки новый объект String и пытается прочитать
        значение свойства len. Строки не имеют данного свойства, поэтому выражение возвращает значение
        undefined. Данный фрагмент показывает, что при попытке прочитать значение какого-либо свойства
        (или вызвать метод), строки, числа и логические значения ведут себя подобно объектам. Но если
        попытаться установить значение свойства, эта попытка будет просто проигнорированна: изменение
        затронет только временный объект и не будет сохранено.<br>
        Временные объекты, которые создаются при обращении к свойству строки, числа или логического
        значения, называются объектами-обёртками, и иногда может потребоваться отличать строки от
        объектов String или числа и логические значения от объектов Number и Boolean. Однако обычно
        объекты обёртки можно рассматривать просто как особенность реализации и вообще не думать о них.
        Достаточно будет знать, что строки, числа и логические значения отличаются от объектов тем,
        что их свойства доступны только для чтения и что вы не можете определять для них новые свойства.<br>
        Существует возможность (но в этом нет необходимости или смысла) явно создавать объекты-обёртки
        вызовом конструктора String(), Number(), Boolean():<br>
        var s = "test", n = 1, b = true; // Строка, число и логическое значение<br>
        var S = new String(s); // Объект String<br>
        var N = new Number(n); // Объект Number<br>
        var B = new Boolean(b); // Объект Boolean<br>
        При необходимости интерпретатор JS обычно автоматически преобразует объекты-обёртки, т.е. объекты
        S, N и B в примере выше, в обёртываемые ими простые значения, но они не всегда ведут себя точно
        также, как значения s, n и b. Оператор равенства == считает равными значения и соответствующие им
        объекты-обёртки, но опретатор идентичности === отличает их. Опреатор type of также обнаруживает
        отличия между простыми значениями и их объектами-обёртками.
      </p>
      <h4>Неизменяемые простые значения и ссылки на изменяемые объекты</h4>
      <p>
        Между простыми значениями (undefined, null, логическими значениями, числами и строками) и объектами
        (включая массивы и функции) в языке JavaScript имеются фундаментальные отличия. Простые значения
        являются неизменяемыми: простое значение невозможно изменить или трасформировать. Это очевидно для
        чисел и логических значений - нет никакого смысла изменять значение числа. Однако для строк это
        менее очевидно. Поскольку строки являются массивами символов, вполне естественно было бы ожидать
        наличие возможности менять символы в той или иной позиции в строке. В действительности JS не
        позволяет сделать это, и все строковые методы, которые, на первый взгляд, возвращают изменённую
        строку, на самом деле возвращают новое строковое значение. Например:<br>
        var s = "hello"; // Изначально имеется некоторый текст из строчных символов<br>
        s.toUpperCase(); // Вернёт "HELLO", но значение s при этом не изменится<br>
        s // "hello": оригинальная строка не изменилась<br>
        Кроме того, величины простых типов сравниваются по значению: две величины считаются одинаковыми,
        если они имеют одно и тоже значение. Для чисел, логических значений, null и undefined это
        выглядит очевидным: нет никакого другого способа сравнить их. Однако для строк это утверждение
        не выглядит таким очевидным. При сравнении двух строковых значений JS считатет их одинаковыми
        тогда и только тогда, когда они имеют одинаковую длину и содержат одинаковые символы в
        соответствующих позициях.<br>
        Объекты отличаются от простых типов. Во-первых, они являются изменяемыми - их значения можно
        изменять:<br>
        var o = {x:1}; // Начальное значение объекта<br>
        o.x = 2; // Изменить, изменив значение свойства<br>
        o.y = 3; // Изменить, добавив новое свойство<br><br>

        var a = [1, 2, 3]; // Массивы также являются изменяемыми объектами<br>
        a[0] = 0; // Изменить значение элемента массива<br>
        a[3] = 4; // Добавить новый элемент<br>
        Объекты не сравниваются по значению: два объекта не считаются равными, даже если они будут
        иметь одинаковые наборы свойств с одинаковыми значениями. И два массива не считаются равными,
        даже если они имеют один и тот же набор элементов, следующих в том же порядке:<br>
        var o = {x:1}, p = {x:1}; // Два объекта с одинаковыми свойствами<br>
        o === p; // false - разные объекты не являются равными<br>
        var a = [], b =[] // Два различных пустых массива<br>
        a === b // false - различные массивы не являются равными<br>
        Чтобы подчеркнуть отличие от простых типов JS, объекты иногда называют ссылочными типами. Если
        следовать этой терминологии, значениями объектов являются ссылки, и можно сказать, что объекты
        сравниваются по ссылке: значения двух объектов считаются равными тогда и только тогда, когда
        они ссылаются на один и тот же объект в памяти.<br>
        var a = []; // переменная a ссылается на пустой массив.<br>
        var b = a; // теперь b ссылается на тот же массив<br>
        b[0] = 1; // изменение массива с помощью ссылки в переменной b<br>
        a[0] // 1: изменение можно наблюдать в переменной a<br>
        a === b; // true - a и b ссылаются на один и тот же объект, поэтому они равны.<br>
        Как следует из примера выше, операция присваивания объекта (или массива) переменной, фактически
        присваивает ссылку: Она не создаёт новую копию объекта или массива, необходимо будет явно
        скопировать свойства объекта или элементы массива. Копирование с помощью цикла for:<br>
        var a = ['a', 'b', 'c']; // копируемый массив<br>
        var b = []; // массив, куда выполняется копирование<br>
        for (var i=; i < a.length; i++) { // для каждого элемента в массиве a[]<br>
          b[i] = a[i]; // скопировать элемент a[] в b[]<br>
        }<br>
        Точно также, если потребуется сравнить два отдельных объекта или массива, необходимо будет
        сравнивать значения их свойств или элементов. Функция, сравнивающая два массива:<br>
        function equalArrays(a,b){<br>
          if (a.length != b.length) return false; // Массивы разной длины не равны<br>
            for(var i=0; i< a.length; i++)        // Цикл по всем элементам<br>
              if (a[i] !== b[i]) return false;  // Если хоть один элемент отличается, массивы не равны<br>
            return true;<br>                    // Иначе они равны
        }<br>
      </p>
    </div>
  </div>
</body>

</html>