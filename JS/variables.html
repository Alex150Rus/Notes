<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>variables</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <style>
    p,
    h4,
    h3 {
      padding: 0 40px;
    }

    p {
      text-align: justify;
    }

    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgb(90, 122, 134);
    }

    .container {
      width: 1140px;
      background: white;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="container">
      <h4>Объявление переменных</h4>
      <p>
        Переменные объявляются с помощью ключевого слова var следующим образом:<br>
        var i;<br>
        var sum;<br>
        Один раз использовав ключевое слово var можно объявить несколько переменных:<br>
        var i, sum;<br>
        Объявление переменных можно совмещать с их инициализацией:<br>
        var message = "hello";<br>
        var i = 0, j = 0, k = 0;<br>
        Если начальное значение в инструкции var не задано, то переменная объявляется, но её изначальное значение
        останется неопределённым (undefined), пока не будет изменено программой.
      </p>
      <h4>Повторные и опущенные объявления</h4>
      <p>
        С помощью инструкции var можно объявить одну и ту же переменную несколько раз. Если повторное объявление
        содержит инициализатор, то оно действует как обычная инструкция присваивания. <br>
        Если попытаться прочитать значение необъявленной переменной, JS сгенерирует ошибку. В сторгом режиме
        ошибка также возбуждается при попытке присвоить значение необъявленной переменной. Однако исторически и
        при выполнении не в строгом режиме, если присвоить значение переменной, не объявленной с помощью
        инструкции var, то JS создаст эту переменную как свойство глобального объекта, и она будет действовать
        практически также (но с некоторыми отличиями), как корректно объявленная переменная. Это означает, что
        глобальные переменные можно не объявлять. Однако это считается дурной привычкой и может явится источником
        ошибок, поэтому нужно всегда объявлять переменные при помощи инструкции var.
      </p>
      <h4>Область видимости переменной</h4>
      <p>
        Область видимости (scope) переменной - это та часть программы, для которой эта переменная определена.
        Глобальная перемнная имеет глобальную область видимости - она определена для всей JavaScript прогаммы.
        В то же время переменные, объявленные внутри функции, определены только в её теле. Они называются
        локальными и имеют локальную область видимости. Параметры функции также считаются локальными переменными,
        определёнными только в теле этой функции.<br>
        Внутри тела функции локальная переменная имеет преимущество перед глобальной переменной с тем же именем.
        Если объявить локальную переменну или параметр функции с тем же именем, что у глобальной переменной, то
        фактически глобальная переменная будет скрыта:<br>
        var scope = "global"; //объявление глобальной переменной<br>
        function checkscope() {<br>
          var scope = "local"; // объявление локальной переменной с тем же именем<br>
          return scope; // вернёт локальное значение, а не глобальное<br>
        }<br>
        checkscope() // "local"<br>
        Объявляя перемнные с глобальной областью видимости, инструкцию var можно опустить, но при объявлении
        локальных переменных её всегда следует использовать. Иначе:<br>
        scope = "global"; // объявление глобальной переменной без var <br>
        function checkscope2() {<br>
          scope = "local"; // Ой)) Мы изменили глобальную переменную.<br>
          myscope = "local"; //Неявно объявляется новая глобальная переменная<br>
          return [scope, myscope]; // возвращаем два значения<br>
        }
        checkscope2() // ["local","local"] - имеется побочный эффект!<br>
        scope // "local": глобальная переменная изменилась<br>
        myscope // "local" - нарушен порядок в глобальном пространстве имён.<br>
        Определения функций могут быть вложенными. Каждая функция имеет собственную локальную область видимости,
        поэтому может быть несколько вложенных уровней локальных областей видимости:<br>
        var scope = "global scope"; // Глобальная переменная<br>
        function checkscope() {<br>
          var scope = "local scope"; // Локальная переменная<br>
          function nested(){<br>
            var scope = "nested scope"; // Вложенная область видимости локальных переменных<br>
            return scope;<br>
          }<br>
          return nested();<br>
        }<br>
        checkscope(); // "nested scope"
      </p>
      <h4>Область видимости функции и подъём</h4>
      <p>
        Область видимости функции: переменные, объявленные внутри функции, доступны внутри функции, где Они
        объявлены, а также внутри всех функций, вложенных в эту функцию.<br>
        В следующем фрагменте переменные i, j, и k объявляются в разных местах, но все они имеют одну и ту
        же область видимости - все три переменные доступны из любого места в теле функции:<br>
        function test(o) {<br>
          var i = 0;  // i определена в теле всей функции<br>
          if (typeof o == "object") {<br>
            var j = 0;  // j определена везде, не только в блоке<br>
            for (var k=0; k < 10; k++) { // k определена везде, не только в цикле<br>
              console.log(k); // выведет числа от 0 до 9<br>
            }<br>
            console.log(k); // k по прежнему определена: выведет 10<br>
          }<br>
          console.log(j); //j опеределена, но может быть не инициализированна<br>
        }
      </p>
    </div>
  </div>
</body>

</html>