<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>widgets-yii2</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />
  <style>
    p,
    h4 {
      padding: 0 40px;
    }

    .content {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgb(90, 122, 134);
    }

    .container {
      width: 1140px;      
      background: white;
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="container">
      <h4>Вспомогательные классы, формы, виджеты</h4>
      <p>
        Виджеты в рамках YII - это отдельные структуры (элементы html), которые мы инкапсулируем в виде объектов:<br>
        кнопка, форма, календарь. Виджет подразумевает под собой повторное использование. На любые стандартные и<br>
        нестандартные задачи можно найти виджеты и расширения. Виджеты можно вызвать двумя способами:<br>
        1) статический метод widget. echo Nav::widget([]) он отдаёт нам html в виде строки.<br> 
        2) методы begin и end. Navbar::begin(), Navbar::end(). Html получаем, когда вызываем метод end.<br>
        Это используется в случае, если виджет распределён, (например, у нас есть форма с открывающим тэгом<br>
        и закрывающим, но при этом внутри формы также есть содержимое). Также это используется, когда нужно<br>
        поднастроить виджет в зависимости от какой-то логики.<br><br>
        
        <b>Виджет ActiveForm</b> - используется для постройки формы с привязкой к какой-то модели. Создаётся вьюха<br>
        и контроллер -наследуется от Controller, в методе actionIndex пишем $model = new Test()<br>
        return $this->render('index', ['model' => $model]);  Теперь идём в виджет: У нас распределённый виджет<br>
        $model = \yii\widgets\ActiveForm::begin([сюда можно передать конфигурацию формы, id]); Всё это заканчивается<br>
        \yii\widgets\ActiveForm::end(); - поставит закрывающий тэг. Также в начале файла можно указать пространство<br>
        имён, чтобы каждый раз его не писать: use \yii\widgets\ActiveForm; и между этими тэгами мы начинаем заниматься<br>
        выводом формы с привязкой к модели. В начале файла пишем jsDoc /** @var \app\models\tables\Test $model */.<br>
        между этими тэгами мы начинаем заниматься выводом формы с привязкой к модели.<br>
        echo $form->field($model, 'title') ->textInput(['class' => 'myClass']).Метод field создаёт поле, в котором будет<br>
        использоваться input и именно feiled занимается привязкой инпута к какому-либо атрибуту модели.<br>
        Дальше выбираем метод - каким именно элементом будет поле - выберем textInput(), в него можем передать options -<br>
        html атрибуты. Дальше по цепочке вызовов можно переопределить разные настройки, например label, если не устраивает<br>
        подпись по автомату или её нет, можно указать всплывающую подсказку при наведении (hint). На самом деле всё это<br>
        виджеты, но они вызываются за кадром. Если модель пришла не чистой, но заполненной, то также будут заполнены поля формы.<br>
        Преимущество activeForm - ставит атрибуты name в соответствии с нашей ActiveRecord, а метод пост возвращает массив,<br>
        в котором есть ключ с именем нашей Ar, а его значение - массив с ключами, являющимися атрибутами/полями нашей AR,<br>
        ну а их значения - данные формы. <br><br>
        
        <b>Добавим кнопочку.</b> Use \yii\helpers\Html; echo Html::submitButton('Отправить', ['class' =>'btn btn-success']).<br>
        Это специальный хэлпер для вывода html элементов.<br><br>
        
        <b>Как писать html, в объектном стиле, или чистой вёрсткой?</b> Работаешь один - ооп, в команде с верстальщиками - вёрсткой.<br>
        Обычно всё делается вёрсткой, но только не формы, так как Yii Им автоматически добавляет csrf токен.<br><br>
        
        <b>Создадим свой виджет</b>. В папке widget создаём класс MyWidget extends Widget. Переопределяем метод run.<br>
        Он запускается в двух случаях: когда вызываем метод widget, либо метод end. Т.е. метод run должен выдавать нам<br>
        готовый виджет. Public function run() {return 'вёрстка'} . Идём во вьюху и пишем echo \app\widgets\MyWidget::widget();<br>
        В классе можно задать атрибуты и их использовать в методе run. Потом их можно конфигурировать.<br>
        $message = world; public function run() {return 'тэг Hello, $this->message тэг'} . А во вьюхе пишем -<br>
        MyWidget::widget(['message']=>'user'). Держать шаблон внутри класса - не правильно. Его нужно хранить в том файле,<br>
        где хранится вёрстка. Поэтому в папке widgets можно создать папку views и положить шаблон туда в файл my.php в виде<br>
        тэг Hello, ?=$message?> тэг. А метод run переделать на return $this->render('my', ['message'=>$this->message]).<br>
        Это является best practice.Если нам что-то нужно вывести через метод (begin) - то нам нужно переопределить метод init.<br>
        Метод init есть в каждом классе. Любой конструктор вызывает метод Init.<br> 
        Допустим public function init() {echo "div class='my'"} а в шаблоне метода run добавим в конце div.<br>
        Теперь виджет можно вызвать и вторым способом: MyWidget::begin(); MyWidget::end();<br><br>

        <b>Виджет DetailVeiw</b> (табличка для отображения данных по одной модельке) -<br>
        DetailVeiw::widget(['model'=> $model, 'attributes'=> ['id', 'name', 'description',<br>
        ['label'=>'свой атрибут', 'value' => 'значение атрибута']]]). Это табличка на тегах tr, td, мы можем её переделать,<br>
        переопределив следующие свойства:  $template (вёрстка на каждую строчку) переопределяем его под атрибутом 'model'<br>
        - смотри сверху. Через атрибут options  можно не устанавливать атрибуты html и поменять оборачивающий tag через атрибут tag.<br>
        'options' => ['tag' => 'div']. В атрибутах можно задать тип - 'description:html' и тогда вёрстка, лежащая в БД отобразится<br>
        не как текс а как вёрстка, есть ещё формат date и т.д.<br<br>
        
        Следующий виджет -<b>ListView</b> - виджет в yii дляотображения данных по группе. Самый простой его вариант<br>
        echo ListView::widget(['dataProvider' => $dataProvider, 'itmeView - указывваем шаблон -своего у него нет']=>'view').<br>
        view применяется для каждого из элементов дата провайдера. Так, dataPrivider - у нас есть AciveDataProvider<br>
        (в него передаётся наш ActiveQuery), ArrayDataProvider(принимает массив), SqlDataProvider<br>
        (принимает данные из базы на основании sql запроса). Это специальный объект, который в себя принимает либо набор данных,<br>
        либо условия для получения этого набора данных и он управляет выдачей (пагинация, сортировка) данный из этого набора.<br>
        Используя dataProvider можно настроить сортировку, пагинацию. $dataProvider = new ActiveDataProvider(['query' => $query],<br>
        'pagination'=>['pageSize' => 2]) Дата провайдер модифицирует query - добавляет туда limit и ofset - т.е. смещение по<br>
        базе данных(для каждой странички считывает две строки из БД , а отрисовывет навигацию - ListVeiw, в строке url появляется<br>
        &page=2&per-page=2. В ListVeiw можно передать дополнительные переменные 'viewParams'=>  ['hide' => true]
      </p>
    </div>
  </div>
</body>

</html>